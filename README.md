# AI Blog Generator
AI Blog Scheduler using APScheduler with OpenAI in a Flask app.

## Quickstart

Clone the repository and open a terminal. On the terminal, navigate to the project 
root directory.

Install required dependencies with the following command:

```bash
pip install -r requirements.txt
```

You may find it helpful to install dependencies and run the app from a python 
virtual environment (instructions [here](https://packaging.python.org/en/latest/guides/installing-using-pip-and-virtual-environments/)).

In the project root, create a `.env` file. Inside this file, provide your 
OpenAI API Key, like in this example:
```
OPENAI_API_KEY=some_key
```

From the project root directory, run the following command to start the flask 
app:

```bash
python -m app
```

This will start the blog generator at localhost:5000.

### Generating a Blog Post

You can generate a blog post by visiting `http://127.0.0.1:5000/generate` in 
your browser with a specific keyword. For example:
```
http://127.0.0.1:5000/generate?keyword=wireless_earbuds
```

After several seconds, you will see the blog post on screen (in JSON format) 
as well as in the terminal (where your flask app started from).

### Viewing Blog Posts Made by the Scheduler

Generated blog posts are available to view as markdown files 
in the `/generated_posts` directory in the project root.

They will also be printed to the console (your terminal) every time a job completes.

## Future Improvements
I originally intended to ship this blog generator with a frontend that would:
- Allow users to query the `/generate` endpoint with a keyword and see the 
generated blog post, and
- Allow users to browse/view all posts generated by the APScheduler

I considered two avenues for deploying the blog generator app with this frontend: 

1. Deploy the Flask app bundled together with a React frontend, using Vercel's 
serverless deployment functionality, or

2. Dockerizing the flask app and deploying it on the cloud 
(e.g. Microsoft Azure Container Instance). I would then deploy the frontend 
separately (e.g. on Vercel).

For the sake of time, and to keep the endpoint names + project structure close to 
the project requirements, I decided to submit the flask app on its own.

For future improvements, I would consider:
- Deploying the app according to one of the above strategies
- Using a real SEO metrics API
